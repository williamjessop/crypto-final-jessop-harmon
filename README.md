# Repo Details

| Name                | Value                                            |
| :------------------ | :---------------------------------------------   |
| **Course**          | CSCI310 - Advanced Programming Cryptocurrencies  |
| **Section**         | 1                                                |
| **Semester**        | Fall 2021                                        |
| **Students**        | William Jessop & Dakota Harmon                   |
| **GitHub Usernames**| williamjessop & Kota117                          |
| **Repository**      | https://github.com/williamjessop/crypto-final-jessop-harmon |

# Assignment Details
| Name | Value |
| :--- | :--- |
| Name | Ethereum NFT's |
| Description | An example of an Ethereum NFT contract + Driver Code |
| Due Date | 14-Dec-2021 |
| Status | Done |
| Self Grade | 100/100 |
| Notes | The full description of this project is below in this README.|

---
## Project Description
For this project, we deployed our own NFT contracts to the Ethereum *Ropsten* testnet blockchain. We began by following simple tutorials and deploying the code that we found online. We then made a simple restriction on the contract that we found online and deployed that contract as well. 

The project runs in nodejs and makes use of many different libraries and services as described below. The contract code is written in the programming language Solidity.

##### Important note: This project was pair programmed. Although "williamjessop" is tagged on most commits, both "williamjessop" and "Kota117" programmed this project as a team.

---

## Project Structure
Much of the code in this repo is based on example code found on ethereum.org and hardhat.org. Some of the files were also autogenerated by Hardhat. The second commit in the repository shows code that was autogenerated with the command `npx hardhat`.

#### Contracts Folder

The folder with the most interesting code is the contracts folder. This folder contains the Solidity code that we deployed to the Ethereum testnet chain. The code in "Greeter.sol" was an example that was autogenerated by Hardhat. You can see that example code [here](https://hardhat.org/getting-started/#compiling-your-contracts). The code in "MyNFT.sol" is based on this [NFT tutorial](https://ethereum.org/en/developers/tutorials/how-to-write-and-deploy-an-nft/). 

We added a restriction to the MyNFT contract that only allows a single NFT to be minted. This allowed us to create our final project token. 

#### Scripts Folder
The scripts folder contains driver code that Hardhat can use to deploy Ethereum contracts. The code in "sample-script.js" was autogenerated by Hardhat. The code in "deploy-NFT.js" was based on the "sample-script.js" code. 

The code in "generateAddress.js" is based on a tutorial we found [here](https://www.quicknode.com/guides/web3-sdks/how-to-generate-a-new-ethereum-address-in-javascript). This utility gave us the ability to create an Ethereum wallet without signing up for an outside service or hosting a full geth client. 

The code in the "mint-NFT.js" file is based on the [NFT tutorial](https://ethereum.org/en/developers/tutorials/how-to-write-and-deploy-an-nft/) code. We updated this code to load more details from an environment file to make it more reusable.

#### Test Folder
This folder contains the testing scripts used throughout the project. The code in "sample-test.js" was autogenerated by Hardhat during its initialization. The code in "nft-test.js" was written by us and based on "sample-test.js". 

#### The Configuration Files
In the root of the repository, there are 3 configuration files. The "package.json" and "package-lock.json" files are autogenerated by npm for managing dependencies in a nodejs project. Also in the root of the repo, you will find a "hardhat.config.js" file. The majority of this file was autogenerated by Hardhat. We modified the file with our configuration for an external network (AKA Alchemy). For the project to work, one would also need to add a ".env" file in the root of the repo that would contain application secrets like API keys and Ethereum account private keys.

#### Notes Folder
The notes folder was for us to keep track of what we were learning about Ethereum and NFT's. This folder does not serve a purpose for the code. The notes are stored in markdown and can be viewed with an app called Obsidian. 

---
## Tools used

For this project to work we combined many outside tools and libraries together. The particular tools we used and what we used them for is listed below. 
### Alchemy
For this project, we used a suite of different tools. We did not start our own Ethereum node and instead, we connected to a service known as [Alchemy](https://www.alchemy.com). This service allowed us to make Ethereum API calls without hosting our own full node. This service provides similar functionality to the Coinbase APIs.

### Hardhat
[Hardhat](https://www.hardhat.org) is the set of development libraries we used to automate the deployment and testing of our contract code. It is a commonly used Ethereum JS client library that wraps commonly used actions into API calls that make life easy. Hardhat relies on other dependencies such as web3 (A JS+Ethereum extension) and Ethers.js (Another JS+Ethereum extension).

### S3
We used a service from Amazon Web Services known as the Simple Storage Service (or S3) to publicly host assets that we made NFT's out of. A better approach would be to use a decentralized filesystem like IPFS or a service that specifically hosts NFT content. However, we instead decided to use S3 because it was no additional cost to us and we already had access to AWS. This created a complication for our project as it was now on use to prove integrity of files that are hosted. More about how we accomplished this is below.

### Testing W/ Mocha
To test our contract code we used the default library that is chosen by Hardhat. This happens to be the JS testing library known as Mocha. In addition to Mocha, we made use of some custom test matchers that were included from Hardhat.

### Open Zeppelin Libraries

The code for the final contract we deployed is in "MyNFT.sol". In this contract we decided to not reinvent the wheel and use outside libraries. These libraries were included "openzeppelin". We included 4 scripts from openzeppelin and what they do for us is described below.

The "Counters.sol" script that we imported makes a simple counter that can be incremented or decremented in your contract. 

The "Ownable.sol" script that we imported actually has to do with ownership of the deployed contract. in our contract only the owner of the contract can mint an NFT. The "Ownable.sol" script gives our contract the ability to distinguish the owner of the contract and transfer ownership of the contract to another account.

The "ERC721.sol" and "ERC721URIStorage.sol" scripts are the largest pieces we imported. These libraries include the standard implementation of an NFT (also known as an ERC-721 Token). These files most notably give us the ability to mint an NFT and include an arbitrary URI with that NFT that can link to the NFT content.

### Additional Tools
There are a handful of other pieces we used to make this project work. 

We used a library known as dotenv to manage our environment and secret keys. 

We used a tool known as [Etherscan](https://ropsten.etherscan.io/) to find our transactions and contracts on the test chain.

We also used 2 Ethereum faucets to get test coins for our project. They can be found here: 

https://faucet.dimensions.network/

https://faucet.ropsten.be/


---

## The Journey to an NFT
During this project, we spent a lot of time deploying a proper NFT. We first began by deploying the "Greeter" contract that was autogenerated by Hardhat. This gave us the ability to test the tools we were using and make sure everything was working properly. 

After that we dived right into making NFT's. The first NFT contract we deployed was based on the tutorial from ethereum.org. This contract imports the standard library for an ERC-721 token contract, also known as an NFT. Deploying this contract gave us the ability to test our driver code and make sure we understood how to interact with Ethereum contracts.

After the first NFT, we wanted to add a restriction to the basic tutorial contract. We decided that it would be interesting to restrict our contract such that only a limited number of NFT's can be minted. We then deployed the second NFT contract under the symbol "LIM". In this contract there can only be a total of 5 NFT's minted. Deploying this NFT was useful because we learned how to write the automated tests for an Ethereum contract. We did not mint any NFT's on the testnet chain using this contract, but we did test is locally to make sure everything was working as we expected.

We then began preparing to deploy our final NFT. For this NFT we wanted to create a unique document that could stand in as our submission for this assignment. We created that document as a JSON object and hosted it in S3. We also reduced the NFT limit in the contract from 5 to 1. We then minted the final submission NFT.

It was at this point that we realized that what we had been making were not proper NFT's. This is mostly because of our choice to use S3 to host the NFT data. S3 is a fine service for hosting data on the internet but it does have a problem as far as NFT's go. The data that is hosted in S3 can be modified. If we had decided to use an NFT hosting platform the integrity of the NFT data would be managed for us, but we decided to use a different solution.

In the actual final NFT (Hosted on the symbol HFIN) we included a document hash. We created a hash of the JSON document that we hosted in S3 and included that hash as part of the name of the document. This adds the ability to prove that the NFT hosted in S3 has not been changed since the NFT was minted. In addition to this, we also hosted an image of this Git repo in S3 and provided a link to it in the JSON document.

This describes our journey when it comes to learning about and implementing an NFT. While we did use a lot of example code, we made sure to spend time understanding that code fully.

---
## The Project Pieces on the Chain

In the above we described how we deployed many contracts and made many transactions during this project. If you want to see these interactions for yourself you can use [Etherscan](https://ropsten.etherscan.io/) to search any of the addresses below to see the full details. If you search our external account, you should be able to see all of the transactions we sent during this project.

### List of Project Addresses
| Label | Type | Symbol | Address |
| :--- | :--- | :--- | :--- |
| Our Wallet | External Account | (N/A) | 0xFEA8fFcDeD93ac2Be58fD43b1B9741Bcf873ED1d |
| First Contract Deployed | Contract | (N/A) | 0xFebDC55A7Fd3E6dd7BDcB37c4B17bA36Ef1714e1 |
| First NFT Deployed | ERC-721 Contract | TRY | 0xabe543B146FcEe03D173c32933732b1C9533E1B7 |
| Limited NFT | ERC-721 Contract | LIM | 0xD8b26fBa6A98d3E44444f2C885636Fda60ec2a63 |
| Final NFT | ERC-721 Contract | FIN | 0x99a1c91C40E10010A07Db3398c0eF7586215C624 |
| Hashed Final NFT | ERC-721 Contract | HFIN | 0x54d19965014730dC08A5e2588d5aFffF49cFC8fa |

### List of Interesting Transactions
| Label | Action | Transaction Hash |
| :--- | :--- | :--- |
| First Test Contract | Contract Deploy | 0xac96fd958d75517cb90ed38b949c2c479d7058f708ebf6e2dc3a975626d8cacb |
| First NFT Contract | Contract Deploy | 0x9e1e2f5f306fafd25b2f9701c6e6f5c4d9b41dd18949e0f421d81755e7451d06 |
| First NFT | Mint NFT | 0x2080a843fdbffc72711c24c948d169297d2f7b5f2be6ad5e4f89e3492d3974c8 |
| Final NFT Contract | Contract Deploy | 0x798c0df7a640fac6121b032be7bb5a63afc320f5480140a6930dd004c6a4da70 |
| Final NFT | Mint NFT | 0xfebf6ef8537f11b184c09686cccd9842cbd574c0c5f67be51b299cab4fc79cf3 |
| Fail to Mint Past Limit | Mint NFT | 0xe2a9d1000b537666e2a02874b5b420a403a12606071bc35b53ba2c10bd1a5090 |
| Final Hash NFT | Contract Deploy | 0x6c428e3f567b2614a415a2ab197886d058d8639209b235614c89258e9ef0195f |
| Final Hash Mint | Mint NFT | 0x6433f019599eb11f1f84c54c1a0e3eb11cf20258cc76c56f19f5e0b0616d3805 |
